with Debian we can easily setup a Linux based operating system
anything which needs a kernel'based operating system can use Debian:
, it supports a wide range of processor architectures
, it's suitable for systems with limited resources
, the stable releases provide a security proven system for servers

the following instructions show how to prepare a Debian installation media, in a Unix'like operating system
if you don't have a Unix'like operating system installed,
  you can use Debian's (or any other distro's) live image
first make sure that these packages are installed: wget gzip cpio xorriso udisks2
wget2/wget libarchive-tools udisks2
download the files of this project:
; wget2 -r -np https://hashbang.sh/~damoonsaghian/Comshell/
; cd */Comshell/mkdi/
ensure that the files there aren't malicious
insert a USB storage device (at least 700MB), find the device using "lsblk"
now assuming the device is "sdx", and the CPU architecture is "amd64":
; sh mkdi.sh amd64 sdx

now just boot to the USB storage device
it will ask for:
, a root password, and a user account (provide different passwords for user and root)
, confirmation for auto'detected time'zone
, the network configuration (if it's not a simple DHCP wired connection)
, the target device (if there is more than one device), and then installs Debian on it

after reboot, you will see Comshell
press "tab+enter" to open the application launcher
the first character in application launcher:
, space: switch between the first application (usually Comshell) and the prior application
, backspace: close the current application
, enter: open terminal

system commands: poweroff, reboot, logout, suspend, lock

to switch users, disconnected and reconnect your keyboard, or run "su user'name"
"su" without user'name switches to root
running "su user'name" in root, switches immediately, without asking for password

you can set a user for automatic login (lines starting with ";;" must be run as root):
;; autologin enable <user>
but to protect the computer from physical attacks, you have to disable automatic login ("sudo autologin disable"),
  and lock the session when you leave the computer
in addition you must:
, somehow prevent tampering with hardware
, protect boot firmware by a password
, disable changing the boot device
these can make physical attacks more difficult, but keep in mind that
  physical access to a computer is root access, given enough time and resources

to connect to a wireless LAN:
; net wlan
to forget a previously configured wireless network:
; net wlan forget

to pair with a Bluetooth device:
;; bt
to disconnect a Bluetooth device:
;; bt disconnect
to do:
Bluetooth is actually a right choice only for personal devices like headsets
it perfectly makes sense to pair theme per user
since keyboards are used for login, they are paired globally
still, even pairing of keyboards doesn't need root access,
  because when a keyboard is connected, others are disabled
"https://www.freedesktop.org/wiki/Software/systemd/multiseat/"
keyboards must have USB connection, in addition to Bluetooth

to block/unblock a radio device (wlan wwan bluetooth nfc all):
; rf block/unblock device-type

to install packages:
;; apm install package-names
to remove packages:
;; apm remove package-names
"apm" (atomic package manager) uses "apt" and BTRFS snapshots to manage packages in such a way that
  changes on the file'system would be atomic, and does not interfere with the running system
as a result when you add/remove/update packages using "apm",
  the system must be restarted for it to take effect
all of this means that we can have reliable automatic updates

= codev
collaborative development without the need to keep the whole history
flaws of version control systems:
, they double the storage (working directory, local repository)
, their design makes it difficult to modify the history
  so in practice, the whole history must be kept, even if not needed

to initialize a remote host (for "hashbang.sh" hosts, if login fails, it will try to sign you up):
; codev init remote-host user
create a remote repository from the current project directory:
; codev create remote-host
clone:
; codev clone repo
pull:
; codev pull
after merging:
; codev push
