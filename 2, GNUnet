https://www.gnunet.org/en/
https://www.gnunet.org/en/use.html
https://docs.gnunet.org/
https://manpages.debian.org/unstable/gnunet/
https://manpages.debian.org/unstable/gnunet/gnunet.conf.5.en.html
https://git.gnunet.org/

flaws of version control systems:
, they double the storage (working directory, local repository)
, their design makes it difficult to modify the history
	so in practice, the whole history must be kept indefinitely, even if not needed

when we want to publish a project, first we create ref links of the project files, in ".cache/gnunet/publish"
this way GNUnet can publish the files using the indexed method
note that projects reside in non-removable BTRFS'formated disks

when we download a project, a pristine copy is kept untouched in ".cache/gnunet/pristine",
	and ref links will be created in the working directory, and then we can work on our own branch
after a while when we want to pull and merge changes made in the main branch,
	first a three'way diff based on the main branch, pristine, and the working directory,
	will be shown, and the user will be asked to accept different parts of the diff
to send a pull request to the main branch, first publish the pristine and the working directory,
	then send the two addresses to the main developer
	the main developer will make a diff based on these two, plus her own working directory
a pull request can be removed by sending a message to the main developer, and unpublishing the two links

https://manpages.debian.org/unstable/gnunet/gnunet-directory.1.en.html
https://manpages.debian.org/unstable/gnunet/gnunet-fs.1.en.html

https://www.gnu.org/software/diffutils/manual/html_mono/diff.html
https://stackoverflow.com/questions/16902001/manually-merge-two-files-using-diff
file tree diff
https://stackoverflow.com/questions/776854/how-do-i-compare-two-source-trees-in-linux
https://github.com/dandavison/delta
https://github.com/so-fancy/diff-so-fancy
https://diffoscope.org/
https://github.com/MightyCreak/diffuse
http://meldmerge.org/
https://git-scm.com/docs/git-diff

IPVC is a distributed version control system similar to git, but built on IPFS:
https://github.com/martindbp/ipvc
	
".cache" directory will not be published
also do not follow mount points

Libgcrypt and libcrypto (OpenSSL) do not support NTRU Prime; wolfCrypt does
https://openquantumsafe.org/

audio conversasion is already implemented; add video
https://git.gnunet.org/gnunet.git/tree/src/conversation
https://manpages.debian.org/unstable/gnunet/gnunet-conversation.1.en.html
use gio plugin to send and receive from gstreamer
use gstreamer pipewire plugin to access camera
use gtk4 mediafile to put it on gui

GNUnet on wifi mesh -> bandwidth moderator repeaters

backup: two'way diff

forward secrecy:
, separate keys for each mutual relation
, update keys frequently
this means that an attacker must, for each individual,
record all communications, and break a chain of public keys,
because only the first public keys are transfered unencrypted
https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm
key backup:	
, backup (encrypted) private keys, plus public keys of trusted pairs
, key update between pairs occures only when the backup device is connected

= blockchains
as discussed above, decentralized internet is already elegantly implemented by GNUnet,
	but no one is talking about it
compare it with the hype around decentralized asset transfer systems, aka blockchians,
	which are inefficient and unscalable

basically in a blockchain, we have a global append'only database which grows based on consesus between peers
in a consesus process we need to implement a mechanism to prevent Sybil attacks (PoW, PoS ...)
to add a new block, first a leader is selected that proposes the new block
the probability that a node is elected as the leader is proportional to its PoW
after consensus the block is added to the blockchain
so blockchains mean:
, slow transactions (10 to 30 minutes)
, an always growing database
, the whole blockchain must be downloaded for each full node
	typical blockchains with their current number of users,	are hundreds of gigabytes
	now just imagine what would happen if we scale them world wide
	note that, full nodes are necessary if you want private and trustless transactions
		otherwise why bother with blockchains in the first place
		using light nodes means we have to trust miners; how is this better than trusting banks
, the system is completely isolated from external world
	we cannot import external money and assets to the system
	a necessary feature, if we really want to replace current monetary system

it's clear that the motivation behind blockchains is not to replace the current corrupted monetary system,
	because it simply isn't capable to do that, by design
its only purpose is to create a side system for criminal activities
http://my.pages.de/illegalblockchains

to improve blockchains performace and scalability some have introduced some kind of central mechanism
eg permissioned nodes, DAGs ...
suprisingly they still keep the global ledger and all the bad things that comes with it
, Oxen instant tranactions on top of the blockchain is not a real solution (makes it less secure)
	it uses PoS instead of PoW, thus transactions can be cheap
	https://en.wikipedia.org/wiki/Proof_of_stake#Attacks
	https://tokens-economy.gitbook.io/consensus/chain-based-proof-of-stake/proof-of-stake-pos
, DAG based solutions (Hashgraph ...):
	old transactions can be deleted
	fast and cheap transactions
	but they need to be permissioned, otherwise they will be vulnarable to Sybil attacks in low transaction rates
	https://en.wikipedia.org/wiki/Consensus_(computer_science)#Permissioned_versus_permissionless_consensus
	https://en.wikipedia.org/wiki/Consensus_(computer_science)#[Permissionless_consensus_protocols]
, MaidSafe Safe Network:
	why bother when we have GNUnet
	moreover, its complicated group consensus mechanism is useless
	we don't need consensus when there is no global ledger
	https://primer.safenetwork.org/
, Nano utilizes something called a block lattice
	there is still a global database, but it's partitioned, each account has its own blockchain
	and consequetly there is a consensus mechanism using "open representative voting" instead of PoW
	the security of this simple consensus mechanism is due to the structure of its database,
		where each transaction is signed by both sender and receiver
	these choices make the transactions very fast
	maybe this tendency for global blockchains is to have an isolated token based system, and avoid IO nodes
	https://docs.nano.org/integration-guides/the-basics/
	https://docs.nano.org/living-whitepaper/
"a survey of distributed consensus protocols for blockchain networks" https://arxiv.org/pdf/1904.04098.pdf

= trustless secure transaction
an ideal transaction system would be trustless, and without a single point of failure
this doesn't necessarily mean that we have to completely decentralize everything
the process of transaction, intrinsically needs some centralized parts
trying to decentralize it by force, based on an ideology, leads to hideous creatures like Bitcoin

we need special nodes (let's call them IO nodes):
, to import assets from external world
, to prevent double spending, whithout the need for consensus
	(a tricky process, hurting efficiency and scalability)

to prevent a single point of failure, tokens will be signed by multiple IO nodes
violations made by IO nodes (double spendings, refusing valid transactions), will be reported,
	to remove them from next release of GNUnet

tokens contain two fields:
, token type: determining if it's money, or any other kind of asset
, value+hash (for money tokens), or an identifier encoding the physical aspects of an asset
token file: token, timestamp, public key of the owner, signatures of IO nodes
tokens are produced and signed by IO nodes based on real resources

everyone will publish their tokens, using the token's hash as a keyword
so if an IO node does a double spend, it will be detected

transaction request:
, list of provided tokens
, public key of sender
, list of requested tokens, or the value requested in exchange, or a contract
, public key of the receiver
, signature of the sender

first a transaction request is sent from sender to the receiver and all IO nodes
then the receiver sends a compatible answer to IO nodes
then IO nodes do the tranfer, and send signed tokens to sender and receiver
then sender and receiver send back the tokens signed by themselves
IO nodes can now discard the tranaction request/answer

note that IO nodes do not have complete authority, they are just there to prevent double spendings
you own your tokens (signed by IO nodes)

transactions can request to exchange big tokens with small ones and vice versa

the more i think, the more i'm convinced that identities capable to have tokens, must be related to real persons
otherwise, criminal can force people (by kidnapping, violance ...) to send their money/assets to anonymous persons
nonetheless, one can always have different identities hidden from others, but identifiable by IO nodes

taxes, i think, are out of the scope of transaction system
they must be evaluated according to the kind of job and a lot of other factors (like environmental damage)
nonetheless, because of IO nodes, some kind of surveillance can be implemented,
	to prevent criminal activities, without violating privacy of users

we can use this system for voting too
real persons submit a public key in their companies, and then can use their private keys to vote
everyone can see the complete list of votes, and check that her own vote is correctly submited
since the total number of voters is known, there is no place for cheating
