https://www.gnunet.org/en/
https://www.gnunet.org/en/use.html
https://docs.gnunet.org/
https://manpages.debian.org/unstable/gnunet/
https://manpages.debian.org/unstable/gnunet/gnunet.conf.5.en.html
https://git.gnunet.org/

flaws of version control systems:
, they double the storage (working directory, local repository)
, their design makes it difficult to modify the history
	so in practice, the whole history must be kept indefinitely, even if not needed

when we want to publish a project, first we create ref links of the project files, in ".cache/gnunet/publish"
this way GNUnet can publish the files using the indexed method
note that projects reside in non-removable BTRFS'formated disks

when we download a project, a pristine copy is kept untouched in ".cache/gnunet/pristine",
	and ref links will be created in the working directory, and then we can work on our own branch
after a while when we want to pull and merge changes made in the main branch,
	first a three'way diff based on the main branch, pristine, and the working directory,
	will be shown, and the user will be asked to accept different parts of the diff
to send a pull request to the main branch, first publish the pristine and the working directory,
	then send the two addresses to the main developer
	the main developer will make a diff based on these two, plus her own working directory
a pull request can be removed by sending a message to the main developer, and unpublishing the two links

https://manpages.debian.org/unstable/gnunet/gnunet-directory.1.en.html
https://manpages.debian.org/unstable/gnunet/gnunet-fs.1.en.html

https://www.gnu.org/software/diffutils/manual/html_mono/diff.html
https://stackoverflow.com/questions/16902001/manually-merge-two-files-using-diff
file tree diff
https://stackoverflow.com/questions/776854/how-do-i-compare-two-source-trees-in-linux
https://github.com/dandavison/delta
https://github.com/so-fancy/diff-so-fancy
https://diffoscope.org/
https://github.com/MightyCreak/diffuse
http://meldmerge.org/
https://git-scm.com/docs/git-diff

IPVC is a distributed version control system similar to git, but built on IPFS:
https://github.com/martindbp/ipvc
	
".cache" directory will not be published
also do not follow mount points

Libgcrypt and libcrypto (OpenSSL) do not support NTRU Prime; wolfCrypt does
https://openquantumsafe.org/

audio conversasion is already implemented; add video
https://git.gnunet.org/gnunet.git/tree/src/conversation
https://manpages.debian.org/unstable/gnunet/gnunet-conversation.1.en.html
use gio plugin to send and receive from gstreamer
use gstreamer pipewire plugin to access camera
use gtk4 mediafile to put it on gui

GNUnet on wifi mesh -> bandwidth moderator repeaters

backup: two'way diff

forward secrecy:
, separate keys for each mutual relation
, update keys frequently
this means that an attacker must, for each individual,
record all communications, and break a chain of public keys,
because only the first public keys are transfered unencrypted
https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm
key backup:	
, backup (encrypted) private keys, plus public keys of trusted pairs
, key update between pairs occures only when the backup device is connected

= trustless secure transaction
as discussed above, decentralized internet is already elegantly implemented by GNUnet,
	but no one is talking about it
compare it with the hype around decentralized transaction systems, aka blockchians,
	which are inefficient and unscalable:
, transactions are really slow (10 to 30 minutes)
, an always growing database
, the whole blockchain must be downloaded for each full node
	typical blockchains with their current number of users,	are hundreds of gigabytes
	now just imagine what would happen if we scale them world wide
	note that, full nodes are necessary if you want private and trustless transactions
		otherwise why bother with blockchains in the first place
		using light nodes means we have to trust miners; how is this better than trusting banks
, the system is completely isolated from external world
	we cannot import external money and assets to the system
	a necessary feature, if we really want to replace current monetary system

it's clear that the motivation behind blockchains is not to replace the current corrupted monetary system,
	because it's just not capable to do that, by design
its only purpose is to create a side system for criminal activities
http://my.pages.de/illegalblockchains

an ideal transaction system would be trustless, and avoid having a single point of failure
this doesn't necessarily mean that we have to completely decentralize everything
the process of transaction, intrinsically needs some centralized parts
trying to decentralize it by force, based on an ideology, leads to hideous creatures like Bitcoin

we need special nodes (let's call them IO nodes):
, to import assets from external world
, to prevent double spending, whithout the need for a consensus mechanism
	(a tricky process, hurting efficiency and scalability)

tokens contain two fields:
, token type: determining if it's money, or any other kind of asset
, value+hash (for money tokens), or an identifier encoding the physical aspects of an asset

token history file: the token as the file name, containing history entries
each history entry is a line which can be continued by following indented lines
history lines: timestamp, a public key made by the owner (at that time),
	signature made by the private pair of the key in the previous line,
	or, in the case of the first line, the signature made by the IO node

owners produce separate keys for each token and for each IO node
so each IO node will have a different token history file
so even if an IO node is hijacked, it jus has access to its own public keys, not the ones in other IO nodes

so even if someone hijacks all IO nodes, still:
, he can't issue fake tokens, or double spaend tokens, without being detected
, he can't steal tokens, because for each token, he needs all the private keys,
	the last owner used to sign the token with

tokens are produced and signed by IO nodes based on real resources
to prevent a single point of failure, tokens will be signed by multiple IO nodes	

each IO node publishes all the issued tokens
for each token, a file will be published, with the token as the file name
	the file contains the signature of the latest owner
	the signature is made by the owner's public key, not the key in the history file
so IO nodes can't make fake tokens, or double spend a token, without being detected
violations made by IO nodes (double spendings, refusing valid transactions), will be reported,
	to remove them from next release of GNUnet
IO nodes do not have any power, they are just there to prevent double spending
you own your tokens signed off by IO nodes and all the previous owners

transaction request:
, timestamp
, list of provided tokens
, list of requested tokens, or the value requested in exchange, or a contract
, address of the receiver

first a transaction request is sent from sender to the receiver and all IO nodes
then the receiver sends a compatible answer to IO nodes
IO nodes sign the request and answer, and send it back to the sender and receiver
sender and receiver sign off their tokens and send them to the IO nodes
IO nodes send the tokens to their new owners
if any IO node receives the signed off tokens, but does not send them back to their new owners,
	they can be reported using the transaction request/answer which has their signature

transactions can be exchange requests, for exchanging big tokens with small ones,
	in which case the receiver address will be empty

the more i think, the more i'm convinced that identities capable to have tokens, must be related to real persons
otherwise, criminal can force people (by kidnapping, violance ...) to send their money/assets to anonymous accounts
nonetheless, one can always have different identities hidden from others, but identifiable by IO nodes

taxes, i think, are out of the scope of transaction systems
they must be evaluated according to the kind of job and a lot of other factors (like environmental damage)
nonetheless, because of IO nodes, some kind of surveillance can be implemented,
	to prevent criminal activities, without violating privacy of users

we can use this system for voting too
real persons submit a public key in their companies, and then can use their private keys to vote
everyone can see the complete list of votes, and check that her own vote is correctly submited
since the total number of voters is known, there is no place for cheating
