
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Codev</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Codev'><h1>Codev</h1></a>
<h2>1, Codev</h2><div>Codev (collaborative development) is a command based user interface,</div><div>	providing a project based development environment, and an ideal frontend for GNUnet</div><div><p></p></div><div><b>command based user interface</b></div><div>command based user interfaces (using keyboard, voice, gesture) are faster, more convenient and more powerful,</div><div>	than pointer based user interfaces (using mouse, touch, pen)</div><div>pointer based interface seems appealing at first sight, because of its discoverability</div><div>but with simple uniform GUI (ie the oposite of what we see in websites),</div><div>	there is no need for a pointer based user interface</div><div><p></p></div><div>touch interface has an additional problem: interaction at a distance is not possible</div><div>it can be useful in some special cases, but is not a good choice as a general interface</div><div><p></p></div><div>detection of voice commands is a relatively simple process (compared to general speech recognition),</div><div>	because we only need to match against a relatively small set of commands</div><div>a headset with near range microphone can be used, to exclude far away sound sources</div><div>also it is better to put battery and transmitter of the headset in a separate unit which can be put in a pocket</div><div>	this makes the headset lighter and safer</div><div><p></p></div><div>for those who neither can use all their fingers, nor can talk, gesture based (2d) input can be implemented</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div><a href='https://github.com/abstracthat/dactyl-manuform'>https://github.com/abstracthat/dactyl-manuform</a></div><div><a href='https://zealot.hu/absolem/'>https://zealot.hu/absolem/</a></div><div><a href='https://github.com/foostan/crkbd'>https://github.com/foostan/crkbd</a></div><div><a href='https://github.com/nglgzz/42'>https://github.com/nglgzz/42</a></div><div><a href='https://github.com/adereth/dactyl-keyboard'>https://github.com/adereth/dactyl-keyboard</a></div><div>Kinesis Advantage 2 keyboard</div><div><a href='http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/'>http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/</a></div><div><p></p></div><div>the keyboard has two modes: insert mode and action mode</div><div>in action mode keys are mapped to navigation keys (arrows, page up, page down, home, end, esc),</div><div>	and ctrl/alt based keybindings</div><div>in action mode, "pun" key acts like "alt" key</div><div>in action mode, press "space" to go to insert mode</div><div>when "action" is pressed keyboard sends a special key combination,</div><div>	which can be used by applications, eg to flash the location of the cursor</div><div><p></p></div><div>to insert punctuations (in insert mode), press "pun"</div><div>	after entering a punctuation charactor, it automatically returns to normal insert mode</div><div>to insert numbers, press and hold "num"</div><div><p></p></div><div>to insert capital letters, press comma then press the letter</div><div>to insert an all capital word, press two commas</div><div>	the following letters will be inserted in capitalized form, until space is pressed</div><div>this is how it's implemented:</div><div>when comma key is press, keyboard enters the cap mode in which:</div><div>, pressing a letter key, sends a "backspace" key, and then the capitalized form of that letter,</div><div>	and then the cap mode will be canceled</div><div>, pressing comma again, sends a "backspace" key, and activates caps mode,</div><div>	which remains active until space (or enter or action) is pressed</div><div>, pressing any other keys, acts like normal, and cancels the cap mode</div><div><p></p></div><div>for compatibility with other applications, we may still need a mouse,</div><div>	plus "ctrl" and "shift" keys which can be put in the middle of the keyboard</div><div>for full compatibility we can add a row of function keys, plus the "delete" key</div><div><p></p></div><div><b>project based development environment</b></div><div>list of all projects will appear in a floating layer, at the center of the screen, called overview layer</div><div>overview layer:</div><div>, left panel:</div><div>	, roots: user home plus attached devices</div><div>	, project groups: content of roots</div><div>, main view:</div><div>	projects: content of project groups</div><div><p></p></div><div><img src='codev.png' alt='codev.png'/></div><div><p></p></div><div>in a project view, the list of files of a project will be displayed in the left side'bar</div><div>opened files will be slightly highlighted</div><div>files and directories with names starting with a dot, will be hidden</div><div>".cache" directory inside a project is for files we don't want to share or backup</div><div><p></p></div><div>each opened file will have a side'bar at right showing its sections</div><div>there we can create new view corresponding to a section</div><div>sections with views will be slightly highlighted</div><div><p></p></div><div>text files will be opened in a text editor</div><div>directories containing media files, will be opened in a gallery view</div><div>files and directories inside a gallery, will be opened in a floating layer</div><div><p></p></div><div>non'local projects, web pages, PDF documents, etc, accessed from links inside the main project,</div><div>	will be opened in a floating layer</div><div>web pages: move caret between visual elements (ignoring structural elements)</div><div><p></p></div><div>actions:</div><div>, next/previous word, line, paragraph, section (righ/left middle row keys)</div><div>, next/previous file (ask for confirmation)</div><div>, next/previous section view, opened file</div><div>, go to the list of files to open a new view</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo</div><div><p></p></div><div>, navigation: move, search</div><div>, selection</div><div>, completion</div><div><p></p></div><div>for implementing a prototype of Comshell, it seems that the best tool at hand is PyGObject</div><div>moreover, Python provides a simple consistent glue for almost anything</div>
<h2>2, GNUnet</h2><div>https://www.gnunet.org/en/</div><div>https://www.gnunet.org/en/use.html</div><div>https://docs.gnunet.org/</div><div>https://manpages.debian.org/unstable/gnunet/</div><div>https://manpages.debian.org/unstable/gnunet/gnunet.conf.5.en.html</div><div>https://git.gnunet.org/</div><div><p></p></div><div>flaws of version control systems:</div><div>, they double the storage (working directory, local repository)</div><div>, their design makes it difficult to modify the history</div><div>	so in practice, the whole history must be kept indefinitely, even if not needed</div><div><p></p></div><div>when we want to publish a project, first we create ref links of the project files, in ".cache/gnunet/publish"</div><div>this way GNUnet can publish the files using the indexed method</div><div>note that projects reside in non-removable BTRFS'formated disks</div><div><p></p></div><div>when we download a project, a pristine copy is kept untouched in ".cache/gnunet/pristine",</div><div>	and ref links will be created in the working directory, and then we can work on our own branch</div><div>after a while when we want to pull and merge changes made in the main branch,</div><div>	first a three'way diff based on the main branch, pristine, and the working directory,</div><div>	will be shown, and the user will be asked to accept different parts of the diff</div><div>to send a pull request to the main branch, first publish the pristine and the working directory,</div><div>	then send the two addresses to the main developer</div><div>	the main developer will make a diff based on these two, plus her own working directory</div><div>a pull request can be removed by sending a message to the main developer, and unpublishing the two links</div><div><p></p></div><div>https://manpages.debian.org/unstable/gnunet/gnunet-directory.1.en.html</div><div>https://manpages.debian.org/unstable/gnunet/gnunet-fs.1.en.html</div><div><p></p></div><div>https://www.gnu.org/software/diffutils/manual/html_mono/diff.html</div><div>https://stackoverflow.com/questions/16902001/manually-merge-two-files-using-diff</div><div>file tree diff</div><div>https://stackoverflow.com/questions/776854/how-do-i-compare-two-source-trees-in-linux</div><div>https://github.com/dandavison/delta</div><div>https://github.com/so-fancy/diff-so-fancy</div><div>https://diffoscope.org/</div><div>https://github.com/MightyCreak/diffuse</div><div>http://meldmerge.org/</div><div>https://git-scm.com/docs/git-diff</div><div><p></p></div><div>IPVC is a distributed version control system similar to git, but built on IPFS:</div><div>https://github.com/martindbp/ipvc</div><div>	</div><div>".cache" directory will not be published</div><div>also do not follow mount points</div><div><p></p></div><div>Libgcrypt and libcrypto (OpenSSL) do not support NTRU Prime; wolfCrypt does</div><div>https://openquantumsafe.org/</div><div><p></p></div><div>audio conversasion is already implemented; add video</div><div>https://git.gnunet.org/gnunet.git/tree/src/conversation</div><div>https://manpages.debian.org/unstable/gnunet/gnunet-conversation.1.en.html</div><div>use gio plugin to send and receive from gstreamer</div><div>use gstreamer pipewire plugin to access camera</div><div>use gtk4 mediafile to put it on gui</div><div><p></p></div><div>GNUnet on wifi mesh -&gt; bandwidth moderator repeaters</div><div><p></p></div><div>backup: two'way diff</div><div><p></p></div><div>forward secrecy:</div><div>, separate keys for each mutual relation</div><div>, update keys frequently</div><div>this means that an attacker must, for each individual,</div><div>record all communications, and break a chain of public keys,</div><div>because only the first public keys are transfered unencrypted</div><div>https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm</div><div>key backup:	</div><div>, backup (encrypted) private keys, plus public keys of trusted pairs</div><div>, key update between pairs occures only when the backup device is connected</div><div><p></p></div><div><b>blockchains</b></div><div>as discussed above, decentralized internet is already elegantly implemented by GNUnet,</div><div>	but no one is talking about it</div><div>compare it with the hype around decentralized asset transfer systems, aka blockchians,</div><div>	which are inefficient and unscalable</div><div><p></p></div><div>basically in a blockchain, we have a global append'only database which grows based on consesus between peers</div><div>in a consesus process we need to implement a mechanism to prevent Sybil attacks (PoW, PoS ...)</div><div>to add a new block, first a leader is selected that proposes the new block</div><div>the probability that a node is elected as the leader is proportional to its PoW</div><div>after consensus the block is added to the blockchain</div><div>so blockchains mean:</div><div>, slow transactions (10 to 30 minutes)</div><div>, an always growing database</div><div>, the whole blockchain must be downloaded for each full node</div><div>	typical blockchains with their current number of users,	are hundreds of gigabytes</div><div>	now just imagine what would happen if we scale them world wide</div><div>	note that, full nodes are necessary if you want private and trustless transactions</div><div>		otherwise why bother with blockchains in the first place</div><div>		using light nodes means we have to trust miners; how is this better than trusting banks</div><div>, the system is completely isolated from external world</div><div>	we cannot import external money and assets to the system</div><div>	a necessary feature, if we really want to replace current monetary system</div><div><p></p></div><div>it's clear that the motivation behind blockchains is not to replace the current corrupted monetary system,</div><div>	because it simply isn't capable to do that, by design</div><div>its only purpose is to create a side system for criminal activities</div><div>http://my.pages.de/illegalblockchains</div><div><p></p></div><div>to improve blockchains performace and scalability some have introduced some kind of central mechanism</div><div>eg permissioned nodes, DAGs ...</div><div>suprisingly they still keep the global ledger and all the bad things that comes with it</div><div>, Oxen instant tranactions on top of the blockchain is not a real solution (makes it less secure)</div><div>	it uses PoS instead of PoW, thus transactions can be cheap</div><div>	https://en.wikipedia.org/wiki/Proof_of_stake#Attacks</div><div>	https://tokens-economy.gitbook.io/consensus/chain-based-proof-of-stake/proof-of-stake-pos</div><div>, DAG based solutions (Hashgraph ...):</div><div>	old transactions can be deleted</div><div>	fast and cheap transactions</div><div>	but they need to be permissioned, otherwise they will be vulnarable to Sybil attacks in low transaction rates</div><div>	https://en.wikipedia.org/wiki/Consensus_(computer_science)#Permissioned_versus_permissionless_consensus</div><div>	https://en.wikipedia.org/wiki/Consensus_(computer_science)#[Permissionless_consensus_protocols]</div><div>, MaidSafe Safe Network:</div><div>	why bother when we have GNUnet</div><div>	moreover, its complicated group consensus mechanism is useless</div><div>	we don't need consensus when there is no global ledger</div><div>	https://primer.safenetwork.org/</div><div>, Nano utilizes something called a block lattice</div><div>	there is still a global database, but it's partitioned, each account has its own blockchain</div><div>	and consequetly there is a consensus mechanism using "open representative voting" instead of PoW</div><div>	the security of this simple consensus mechanism is due to the structure of its database,</div><div>		where each transaction is signed by both sender and receiver</div><div>	these choices make the transactions very fast</div><div>	maybe this tendency for global blockchains is to have an isolated token based system, and avoid IO nodes</div><div>	https://docs.nano.org/integration-guides/the-basics/</div><div>	https://docs.nano.org/living-whitepaper/</div><div>"a survey of distributed consensus protocols for blockchain networks" https://arxiv.org/pdf/1904.04098.pdf</div><div><p></p></div><div><b>trustless secure transaction</b></div><div>an ideal transaction system would be trustless, and without a single point of failure</div><div>this doesn't necessarily mean that we have to completely decentralize everything</div><div>the process of transaction, intrinsically needs some centralized parts</div><div>trying to decentralize it by force, based on an ideology, leads to hideous creatures like Bitcoin</div><div><p></p></div><div>we need special nodes (let's call them IO nodes):</div><div>, to import assets from external world</div><div>, to prevent double spending, whithout the need for consensus</div><div>	(a tricky process, hurting efficiency and scalability)</div><div><p></p></div><div>to prevent a single point of failure, tokens will be signed by multiple IO nodes</div><div>violations made by IO nodes (double spendings, refusing valid transactions), will be reported,</div><div>	to remove them from next release of GNUnet</div><div><p></p></div><div>tokens contain two fields:</div><div>, token type: determining if it's money, or any other kind of asset</div><div>, value+hash (for money tokens), or an identifier encoding the physical aspects of an asset</div><div>token file: token, timestamp, public key of the owner, signatures of IO nodes</div><div>tokens are produced and signed by IO nodes based on real resources</div><div><p></p></div><div>everyone will publish their tokens, using the token's hash as a keyword</div><div>so if an IO node does a double spend, it will be detected</div><div><p></p></div><div>transaction request:</div><div>, list of provided tokens</div><div>, public key of sender</div><div>, list of requested tokens, or the value requested in exchange, or a contract</div><div>, public key of the receiver</div><div>, signature of the sender</div><div><p></p></div><div>first a transaction request is sent from sender to the receiver and all IO nodes</div><div>then the receiver sends a compatible answer to IO nodes</div><div>then IO nodes do the tranfer, and send signed tokens to sender and receiver</div><div>then sender and receiver send back the tokens signed by themselves</div><div>IO nodes can now discard the tranaction request/answer</div><div><p></p></div><div>note that IO nodes do not have complete authority, they are just there to prevent double spendings</div><div>you own your tokens (signed by IO nodes)</div><div><p></p></div><div>transactions can request to exchange big tokens with small ones and vice versa</div><div><p></p></div><div>the more i think, the more i'm convinced that identities capable to have tokens, must be related to real persons</div><div>otherwise, criminal can force people (by kidnapping, violance ...) to send their money/assets to anonymous persons</div><div>nonetheless, one can always have different identities hidden from others, but identifiable by IO nodes</div><div><p></p></div><div>taxes, i think, are out of the scope of transaction system</div><div>they must be evaluated according to the kind of job and a lot of other factors (like environmental damage)</div><div>nonetheless, because of IO nodes, some kind of surveillance can be implemented,</div><div>	to prevent criminal activities, without violating privacy of users</div><div><p></p></div><div>we can use this system for voting too</div><div>real persons submit a public key in their companies, and then can use their private keys to vote</div><div>everyone can see the complete list of votes, and check that her own vote is correctly submited</div><div>since the total number of voters is known, there is no place for cheating</div>
<h2>3, computers</h2><div><b>asynchronous digital circuits</b></div><div>in conventional digital circuits when the inputs change, the outputs can have temporary invalid values,</div><div>	until they stabilize to the valid values</div><div>but for the circuit to do its job, gates with memory (registers),</div><div>	must operate only when the inputs have correct values</div><div>one solution is to synchronize registers with a global clock signal</div><div>	the period of clock signal is made long enough for the circuit to become stable</div><div><p></p></div><div>disadvantages of synchronous circuits:</div><div>, we have to split long operations into several smaller ones,</div><div>	which can be performed in successive clock cycles (a technique known as pipelining)</div><div>	otherwise the circuit would be slow and inefficient</div><div>, distributing a high'fan'out, timing'sensitive clock signal can be complicated</div><div>, electromagnetic interference at the clock frequency and its harmonics</div><div>, widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not</div><div>although "clock gating" can help to reduce some of the problems of synchronous circuits,</div><div>	i think the real solution is to use asynchronous circuits</div><div><p></p></div><div>the only sane kind of asynchronous circuit which i could imagine is this:</div><div>, next to any data wire, there is a control wire which determines if the data is valid or not</div><div>, when a register wants to change its outputs, it first invalidates them,</div><div>	for a duration equal to the delay of one gate</div><div>, any gate receiving an invalid input, invalidates its outputs</div><div>, this way all data which is going to change in the future, is first invalidated</div><div>, registers operate only when all inputs are valid</div><div><p></p></div><div><b>computers</b></div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers</div><div>cpu runs a sequence of simple computations, called instruction codes, one by one</div><div><p></p></div><div>compilers are special programs that generate instruction codes,</div><div>	from a program written in a structured and human readable language</div><div><p></p></div><div>there is always possibility of backdoors for closed source CPU,</div><div>	especially if the boot firmware is also closed source</div><div>recently introduction of "secure execution environment" makes this situation even worse</div><div>it's a closed source, full'blown, always'running mini operating system,</div><div>	with full access to the whole system (including memory and network)</div><div>furthermore they have made it practically impossible for users to disable it</div><div>this mess of a design cries out for hidden and quite sophisticated backdoors</div><div><a href='https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me'>https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me</a></div><div><a href='https://libreboot.org/faq.html#intel'>https://libreboot.org/faq.html#intel</a></div><div><a href='https://en.wikipedia.org/wiki/Intel_Management_Engine'>https://en.wikipedia.org/wiki/Intel_Management_Engine</a></div><div><a href='https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf'>https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf</a></div><div><p></p></div><div>on X86 architectures the default boot firmware on nearly all systems are closed source</div><div>flashing a CoreBoot based boot firmware is possible, but there still will be closed source parts (Intel FSP)</div><div>in addition, there is no easy way to get rid of Intel ME (or AMD PSP),</div><div>	though there are some hacks to disable (but not completely remove) it:</div><div>	<a href='https://puri.sm/posts/deep-dive-into-intel-me-disablement/'>https://puri.sm/posts/deep-dive-into-intel-me-disablement/</a></div><div><p></p></div><div>ARM architecture is closed source too, but in most cases, boot firmwares are open source (U-Boot or EDK2)</div><div>ARM TrustZone can host an open source operating system too, apparently:</div><div>	<a href='https://news.ycombinator.com/item?id=17783357'>https://news.ycombinator.com/item?id=17783357</a></div><div>GPU with open source driver: Qualcomm/Adreno</div><div><p></p></div><div>open source CPU: RISC-V, Power ISA</div><div><p></p></div><div>one read'only boot firmware, plus a writable one</div><div>, interrupted flashing does not brick the device</div><div>, no need for complex signing mechanism to make sure a device's firmware is not malicious</div><div>	you just have to make sure that the device boots from the read'only flash,</div><div>	and that the writable flash is empty, the first time you boot the device</div><div><p></p></div><div>programs usually do not run directly on computer hardware</div><div>instead they run on a more sophisticated software machine (a virtual machine) called the kernel</div><div>in theory we can live without a kernel (an idea sometimes called a library operating system),</div><div>	and it can be useful for some use cases (like IoT devices),</div><div>	but a kernel based operating system makes developing and testing programs, much easier</div><div>Linux is a highly developed, constantly evolving, open'source kernel</div>
<h2>4, Alpine Linux</h2><div>using Alpine Linux we can easily setup a Linux based operating system</div><div>anything which needs a kernel'based operating system can use Alpine Linux:</div><div>, it supports a wide range of hardware architectures</div><div>, it's suitable for systems with limited resources</div><div>, the stable release provides a highly tested system for sensitive use cases</div><div><p></p></div><div>the following shows how to create an Alpine live system, on a USB storage device,</div><div>	customized for installing a minimal graphical system</div><div>first you need to already be in an Alpine system (either installed or live)</div><div>then if you need to download the files of this project, run these commands:</div><div>; apk add gnunet</div><div>; gnunet-download -R gnunet://fs/damoonsaghian/Codev</div><div>; cd Codev</div><div>then:</div><div>; sh alpine/alive.sh</div><div>this will ask you to choose a storage device, and then creates the customized live system</div><div><p></p></div><div>now just boot into the customized live system</div><div>it will ask for:</div><div>, a root password, and a user account (provide different passwords for root and for the user)</div><div>, confirmation for auto'detected time'zone</div><div>, the network configuration (if it's not a simple DHCP wired connection)</div><div>, the target device (if there is more than one device), and then installs Alpine on it</div><div>after reboot, you can login to the installed system</div><div><p></p></div><div>press "alt+enter" ("pun+enter" in action mode) to open app launcher menu</div><div>in app launcher menu press "alt+enter" again to open session management menu:</div><div>	lock, suspend, exit, reboot, poweroff</div><div>press and release "alt" ("pun" in action mode) to switch between the primary app (usually Comshell) and the prior app</div><div>press "alt+space" ("pun+space" in action mode) to switch between windows of a workspace</div><div>press "alt+backspace" ("pun+backspace" in action mode) to close focused window</div><div><p></p></div><div>"system" is a command line program which can be used to configure:</div><div>	timezone, language, connections, and installed packages</div><div><p></p></div><div>to run a command as root:</div><div>; su command</div><div>this will switch to the first available virtual terminal, shows the command at the top,</div><div>	and asks for root password</div><div>if the entered password is correct it returns back to previous virtual terminal,</div><div>	and runs the command as root</div><div><p></p></div><div>note that you can't login as root; actually root account is locked,</div><div>	and root password provided during installation, is only used for "su"</div><div>also you must never type the user's password anywhere except at the login prompt</div><div>	(and make sure that the login prompt isn't fake, by disconnecting and reconnecting your keyboard)</div><div>this means that if a malicious program steals root password (eg by faking the password entry),</div><div>	it still can't run programs as root (because it can't enter the password in a virtual terminal)</div><div>take a look at these:</div><div><a href='https://www.reddit.com/r/linuxquestions/comments/8mlil7/whats_the_point_of_the_sudo_password_prompt_if/'>https://www.reddit.com/r/linuxquestions/comments/8mlil7/whats_the_point_of_the_sudo_password_prompt_if/</a></div><div><a href='https://security.stackexchange.com/questions/119410/why-should-one-use-sudo'>https://security.stackexchange.com/questions/119410/why-should-one-use-sudo</a></div><div><p></p></div><div>to protect the computer from physical attacks, don't leave the computer with an unlocked session</div><div>in addition you must:</div><div>, somehow prevent tampering with hardware</div><div>, protect boot firmware by a password</div><div>, disable changing the storage device used for booting</div><div>these can make physical attacks more difficult, but keep this in mind:</div><div>	physical access to a computer is root access, given enough time and resources</div></body></html>