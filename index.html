
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Comshell</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Comshell'><h1>Comshell</h1></a>
<h2>1, Comshell</h2><div><b>command based user interface</b></div><div>command based user interfaces (using keyboard, voice, gesture) are faster, more convenient and more powerful,</div><div>  than pointer based user interfaces (using mouse, touch, pen)</div><div>pointer based interface seems appealing at first sight, because of its discoverability</div><div>but with simple uniform GUI (ie the oposite of what we see in websites),</div><div>  there is no need for a pointer based user interface</div><div><p></p></div><div>touch interface has an additional problem: interaction at a distance is not possible</div><div>but it can still be useful in simple or special applications</div><div><p></p></div><div>detection of voice commands is a relatively simple process (compared to general speech recognition),</div><div>  because we only need to match against a relatively small set of commands</div><div>a headset with near range microphone can be used, to exclude far away sound sources</div><div>also it is better to put battery and transmitter of the headset in a separate unit which can be put in a pocket</div><div>  this makes the headset lighter and safer</div><div><p></p></div><div>for those who neither can use all their fingers, nor can talk, gesture based (2d) input can be implemented</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>, comma followed by a letter -&gt; the symbol on its bottom right corner</div><div>, ";" followed by "psi" followed by space or comma -&gt; "Ïˆ" followed by one space or nothing</div><div>, two apostrophes then an alphabetical letter -&gt; capital letter</div><div>, "aBcd" then two apostrophes followed by one space -&gt; "AbCD" followed by one space</div><div><a href='https://github.com/abstracthat/dactyl-manuform'>https://github.com/abstracthat/dactyl-manuform</a></div><div><a href='https://zealot.hu/absolem/'>https://zealot.hu/absolem/</a></div><div><a href='https://github.com/foostan/crkbd'>https://github.com/foostan/crkbd</a></div><div><a href='https://github.com/nglgzz/42'>https://github.com/nglgzz/42</a></div><div><a href='https://github.com/adereth/dactyl-keyboard'>https://github.com/adereth/dactyl-keyboard</a></div><div>Kinesis Advantage 2 keyboard</div><div><a href='http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/'>http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/</a></div><div><p></p></div><div>for compatibility with other applications, we may still need a mouse,</div><div>  plus these extra keys which can be put in the middle of the keyboard:</div><div>, arrow keys, "page up", "page down", "home", "end", "tab"</div><div>, "alt", "ctrl", "shift"</div><div>and a row of punctuations on top</div><div>also we can have another row for function keys, plus the "delete" key</div><div><p></p></div><div><b>Comshell</b></div><div>Comshell is a unified computing environment, utilizing command based user interface</div><div><p></p></div><div>project directories reside in directories named "projects" or "projects.*",</div><div>  inside home directory or mounted disks</div><div>list of all projects will appear in a floating layer, at the center of screen</div><div>each group of projects (which are in the same directory) will be shown in separate tabs</div><div>here you can open a terminal to do system administration,</div><div>  and to power off, reboot, logout, suspend, or lock the system</div><div><p></p></div><div>in a project view, the list of files of a project will be displayed in the left side'bar</div><div>opened files are indicated by a line below them</div><div>multiple views of a file are indicated by sections in this line</div><div>files and directories with names starting with a dot, will be hidden</div><div>".cache" directory inside a project is for files we don't want to share or backup</div><div><p></p></div><div>text files will be opened in a text editor</div><div>directories with ".g" suffixes, will be opened in a gallery view</div><div>files and directories inside a gallery, will be opened in a floating layer</div><div><p></p></div><div>non'local projects, web pages, PDF documents, etc, accessed from links inside the main project,</div><div>  will be opened in a floating layer</div><div>web pages: move caret between visual elements (ignoring structural elements)</div><div><p></p></div><div>modal key'bindings</div><div>modes (normal mode and insert mode) must be visually distinctive</div><div>press "esc" or "tab" to go to normal mode</div><div>in normal mode we can:</div><div>, press "enter" to go to insert mode</div><div>, move the cursor to the next or previous word</div><div>, move the cursor to the next or previous lines or table cells</div><div>, move the cursor to the next or previous paragraph</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo</div><div>, find</div><div><p></p></div><div>, navigation: move, search</div><div>, selection</div><div>, completion</div><div><p></p></div><div>double space:</div><div>, at the beginning of line: indent</div><div>, otherwise: complete (auto'completion does not disappear with only one space)</div>
<h2>2, computers</h2><div><b>asynchronous digital circuits</b></div><div>in conventional digital circuits when the inputs change, the outputs can have temporary invalid values,</div><div>  until they stabilize to the valid values</div><div>but for the circuit to do its job, gates with memory (registers),</div><div>  must operate only when the inputs have correct values</div><div>one solution is to synchronize registers with a global clock signal</div><div>  the period of clock signal is made long enough for the circuit to become stable</div><div><p></p></div><div>disadvantages of synchronous circuits:</div><div>, we have to split long operations into several smaller ones,</div><div>  which can be performed in successive clock cycles (a technique known as pipelining)</div><div>  otherwise the circuit would be slow and inefficient</div><div>, distributing a high'fan'out, timing'sensitive clock signal can be complicated</div><div>, electromagnetic interference at the clock frequency and its harmonics</div><div>, widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not</div><div>although "clock gating" can help to reduce some of the problems of synchronous circuits,</div><div>  i think the real solution is to use asynchronous circuits</div><div><p></p></div><div>the only sane kind of asynchronous circuit which i could imagine is this:</div><div>, next to any data wire, there is a control wire which determines if the data is valid or not</div><div>, when a register wants to change its outputs, it first invalidates them,</div><div>  for a duration equal to the delay of one gate</div><div>, any gate receiving an invalid input, invalidates its outputs</div><div>, this way all data which is going to change in the future, is first invalidated</div><div>, registers operate only when all inputs are valid</div><div><p></p></div><div><b>computers</b></div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers</div><div>cpu runs a sequence of simple computations, called instruction codes, one by one</div><div><p></p></div><div>compilers are special programs that generate instruction codes,</div><div>  from a program written in a structured and human readable language</div><div><p></p></div><div>there is always possibility of backdoors for closed source CPU,</div><div>  especially if the boot firmware is also closed source</div><div>recently introduction of "secure execution environment" makes this situation even worse</div><div>it's a closed source, full'blown, always'running mini operating system,</div><div>  with full access to the whole system (including memory and network)</div><div>furthermore they have made it practically impossible for users to disable it</div><div>this mess of a design cries out for hidden and quite sophisticated backdoors</div><div><a href='https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me'>https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me</a></div><div><a href='https://libreboot.org/faq.html#intel'>https://libreboot.org/faq.html#intel</a></div><div><a href='https://en.wikipedia.org/wiki/Intel_Management_Engine'>https://en.wikipedia.org/wiki/Intel_Management_Engine</a></div><div><a href='https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf'>https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf</a></div><div><p></p></div><div>on X86 architectures we can have a GPU with open source driver</div><div>but the default boot firmware on nearly all systems are closed source</div><div>flashing a CoreBoot based boot firmware is possible, but there still will be closed source parts (Intel FSP)</div><div>regardless there is no easy way to get rid of Intel ME (or AMD PSP)</div><div>though there are some hacks to disable (but not completely remove) Intel ME:</div><div>  <a href='https://puri.sm/posts/deep-dive-into-intel-me-disablement/'>https://puri.sm/posts/deep-dive-into-intel-me-disablement/</a></div><div><p></p></div><div>ARM architecture is closed source too, but we can have a GPU with open source driver (Qualcomm/Adreno)</div><div>the most used boot firmware is the open source implementation of UEFI called EDK2</div><div>flashing LinuxBoot as a UEFI DXE, or flashing a CoreBoot based boot firmware is possible</div><div>ARM TrustZone can host an open source operating system too, apparently:</div><div>  <a href='https://news.ycombinator.com/item?id=17783357'>https://news.ycombinator.com/item?id=17783357</a></div><div><p></p></div><div>open source CPU: RISC-V, Power ISA</div><div>no adequate hardware available yet</div><div><p></p></div><div>one read'only boot firmware, plus a writable one</div><div>, interrupted flashing does not brick the device</div><div>, no need for complex signing mechanism to make sure a device's firmware is not malicious</div><div>  you just have to make sure that the device boots from the read'only flash,</div><div>  and that the writable flash is empty, the first time you boot the device</div><div><p></p></div><div>programs usually do not run directly on computer hardware</div><div>instead they run on a more sophisticated software machine (a virtual machine) called the kernel</div><div>in theory we can live without a kernel (an idea sometimes called a library operating system),</div><div>  and it can be usefull for some use cases (like IoT devices),</div><div>  but an kernal based operating system makes developing and testing programs, much easier</div><div>Linux is a highly developed, constantly evolving, open'source kernel</div>
<h2>3, Alpine Linux</h2><div>using Alpine Linux Linux we can easily setup a Linux based operating system</div><div>anything which needs a kernel based operating system can use Alpine:</div><div>, it supports a wide range of processor architectures</div><div>, it's suitable for systems with limited resources</div><div>, the stable releases provide a security proven system for servers</div><div><p></p></div><div>current problems of Alpine:</div><div>, Musl's allocator must be replaced with "mimalloc"</div><div>  https://www.linkedin.com/pulse/testing-alternative-c-memory-allocators-pt-2-musl-mystery-gomes/</div><div>  https://github.com/emerzon/alpine-mimalloc/blob/master/Dockerfile</div><div>  https://microsoft.github.io/mimalloc/overrides.html</div><div>, OpenRC must be replaced with "s6"</div><div>  <a href='https://skarnet.com/projects/service-manager.html'>https://skarnet.com/projects/service-manager.html</a></div><div>  <a href='https://skarnet.org/software/s6-rc/why.html'>https://skarnet.org/software/s6-rc/why.html</a></div><div>  <a href='https://skarnet.org/software/s6/why.html'>https://skarnet.org/software/s6/why.html</a></div><div>  <a href='https://skarnet.org/software/s6/'>https://skarnet.org/software/s6/</a></div><div>  <a href='https://github.com/smaeul/rc'>https://github.com/smaeul/rc</a></div><div>  <a href='https://wiki.gentoo.org/wiki/S6_and_s6-rc-based_init_system'>https://wiki.gentoo.org/wiki/S6_and_s6-rc-based_init_system</a></div><div>  <a href='https://framagit.org/architekt/66tools-overlay'>https://framagit.org/architekt/66tools-overlay</a></div><div>  <a href='https://github.com/just-containers/s6-overlay'>https://github.com/just-containers/s6-overlay</a></div><div>  <a href='https://github.com/oznu/docker-s6-alpine'>https://github.com/oznu/docker-s6-alpine</a></div><div>  <a href='https://wiki.artixlinux.org/Main/Migration'>https://wiki.artixlinux.org/Main/Migration</a></div><div>  <a href='https://www.exherbo.org/docs/without-systemd.html'>https://www.exherbo.org/docs/without-systemd.html</a></div><div>  <a href='https://github.com/kisslinux/init'>https://github.com/kisslinux/init</a></div><div>  <a href='https://github.com/jhuntwork/merelinux'>https://github.com/jhuntwork/merelinux</a></div><div>  <a href='https://github.com/Aalbus-linux/Aalbus'>https://github.com/Aalbus-linux/Aalbus</a></div><div>  <a href='https://gitea.com/CasperVector/slew'>https://gitea.com/CasperVector/slew</a></div><div>, in "busybox-initscripts" use "mdevd" instead of "mdev"</div><div>  <a href='https://skarnet.org/software/mdevd/'>https://skarnet.org/software/mdevd/</a></div><div>, all of these must be fixed in "mkinitfs" too</div><div>  <a href='https://gitlab.alpinelinux.org/alpine/mkinitfs'>https://gitlab.alpinelinux.org/alpine/mkinitfs</a></div><div>  <a href='https://github.com/illiliti/tinyramfs'>https://github.com/illiliti/tinyramfs</a></div><div><p></p></div><div>to install Alpine, boot to a live Alpine system (using a disk image or netboot), then:</div><div>; curl https://damoonsaghian/Comshell/archive/master.tar.gz | tar -xz</div><div>; cd Comshell/alpine</div><div>ensure that the files aren't malicious</div><div><p></p></div><div>find the device you want to install Alpine Linux on:</div><div>; fdisk -l</div><div>prepare the disk (note that the content of the disk will be deleted):</div><div>; instalp format sdx</div><div>now install Alpine Linux on it:</div><div>; instalp sdx</div><div>if the installation gets interrupted, just run the last command again (no need to reformat the disk)</div><div><p></p></div><div>after rebooting to the installed system, it will ask for the root password and a user account</div><div>logout of root, and login as the user you provided</div><div><p></p></div><div><img src='sway.png' alt='sway.png'/></div><div><p></p></div><div>to install packages: "alp add package-names"</div><div>to remove packages: "alp del package-names"</div><div>"alp" uses "apk" and BTRFS snapshots to manage packages in such a way that</div><div>  changes on the file'system would be atomic, and does not interfere with the running system</div><div>as a result when you install an application, or update the system using "alp",</div><div>  the system must be restarted for it to take effect</div><div>removing packages is done live though (otherwise managing "/etc" would be complicated)</div><div>all of this means that we can have reliable automatic updates</div><div><p></p></div><div>you can set "user1" for automatic login (run as root):</div><div>; echo 'agetty_options="--autologin &lt;username&gt; --noclear"' &gt; /etc/conf.d/agetty.autologin</div><div>but to protect the computer from physical attacks, you have to disable automatic login,</div><div>  and lock the session when you leave the computer</div><div>in addition you have to:</div><div>, somehow prevent tampering with hardware</div><div>, protect boot firmware by a password</div><div>, disable changing the boot device</div><div>these can make physical attacks more difficult, but keep in mind that</div><div>  physical access to a computer is root access, given enough time and resources</div>
<h2>4, Codev</h2><div>collaborative development without the need to keep it's whole history (as is done in version control systems)</div><div><p></p></div><div>we will have three BTRFS snapshots in a project's <img src='codev/' alt='codev/'/> directory:</div><div>, pristine</div><div>, indexed</div><div>, remote</div><div><p></p></div><div>files will be synced up/down to/from the the remote from/to <img src='codev/indexed' alt='codev/indexed'/></div><div>there is no directory tree here, instead we have an index file</div><div>"project-path/.data/codev/indexed/index"</div><div>entries are separated with empty lines</div><div>each entry has 3 lines:</div><div>, path</div><div>, modification time</div><div>, hash</div><div><p></p></div><div>create a remote repository:</div><div>; codev new</div><div><p></p></div><div>; codev pull</div><div>the shown diff will be based on the working directory, pristine and remote</div><div>after merging:</div><div>; codev push</div><div><p></p></div><div>Codev also automatically backs up all the projects in those directories containing a ".backup-paths" file</div><div>to run it manually:</div><div>; codev backup</div><div><p></p></div><div>add or remove users that can push</div><div>; codev add username1 username2 ...</div><div>; codev remove username1 username2 ...</div><div><p></p></div><div>files in ".cache" directory will not be synced</div></body></html>